# Day 23: 动态规划 - 子序列问题 (Subsequence)

**日期**: 2026-01-07
**主题**: 子数组 vs 子序列、二维 DP 字符串匹配
**标签**: #DynamicProgramming #String

## 🧠 核心概念区分

在 DP 问题中，辨析 **连续性** 至关重要：

1.  **子序列 (Subsequence)**:
    *   **不要求连续**。例如 `[1, 3, 5]` 是 `[1, 2, 3, 4, 5]` 的子序列。
    *   **状态定义**：通常需要 $O(N^2)$ 或二维 DP，因为需要“回头看”之前的状态。
2.  **子数组/子串 (Subarray/Substring)**:
    *   **必须连续**。例如 `[1, 2]` 是，但 `[1, 3]` 不是。
    *   **状态定义**：通常只需要 $O(N)$，因为状态只能由 `i-1` 推导而来，一旦断开就重置。

---

## 题目一：300. 最长递增子序列 (LIS)
**难度**: Medium
**类型**: **子序列 (不连续)**

### 💡 核心思路
不能简单定义为“前 i 个元素的最长长度”，必须定义为 **“以 nums[i] 结尾”** 的最长长度。
这样才能保证递增关系的判断（只有知道结尾是谁，才能知道能不能接在后面）。

### 🔢 状态转移
1.  **定义**：`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度。
2.  **公式**：
    遍历 `i` 之前的所有 `j`：
    $$ \text{if } nums[i] > nums[j]: \quad dp[i] = \max(dp[i], dp[j] + 1) $$
3.  **初始化**：`dp` 全为 1（每个元素自身就是长度 1）。
4.  **结果**：`max(dp)`。

### 💻 关键代码
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        result = 1
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            result = max(result, dp[i])
        return result
```
*(复杂度: Time $O(N^2)$, Space $O(N)$)*

---

## 题目二：674. 最长连续递增序列
**难度**: Easy
**类型**: **子数组 (连续)**

### 💡 核心思路
因为要求 **连续**，`nums[i]` 只需要跟紧挨着的 `nums[i-1]` 比。不需要两层循环。

### 🔢 状态转移
1.  **递推**：
    *   如果 `nums[i] > nums[i-1]`：`dp[i] = dp[i-1] + 1`
    *   否则（断了）：`dp[i] = 1`
2.  **空间优化**：其实只需要一个变量记录当前连续长度即可，不需要数组。

---

## 题目三：1143. 最长公共子序列 (LCS)
**难度**: Medium
**类型**: **二维 DP** (两个字符串)

### 💡 核心思路
涉及两个字符串的子序列问题，标准解法是建立一个 **二维表格**。
行代表 `text1`，列代表 `text2`。

### 🔢 状态转移方程
**定义**：`dp[i][j]` 表示 `text1[0...i-1]` 和 `text2[0...j-1]` 的 LCS 长度。

**错位技巧**：DP 数组大小设为 `(L1+1) * (L2+1)`，其中 `dp[0][0]` 代表空串对比空串。这样可以避免处理 `i-1` 越界问题。

**递推逻辑**：
1.  **字符相等** (`text1[i-1] == text2[j-1]`)：
    *   这个字符一定在 LCS 里。
    *   继承左上角的结果 + 1。
    *   $$ dp[i][j] = dp[i-1][j-1] + 1 $$
2.  **字符不等**：
    *   继承左边或者上边的最大值（相当于删掉 text1 的当前字符，或者删掉 text2 的当前字符）。
    *   $$ dp[i][j] = \max(dp[i-1][j], \quad dp[i][j-1]) $$

### 💻 关键代码
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 注意：dp索引是 i,j，对应字符串索引要减 1
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                    
        return dp[m][n]
```

### 🚀 进阶：空间优化 (滚动数组)
由于 `dp[i]` 只依赖于 `dp[i-1]` (上一行)，我们可以只用两行数组滚动更新。
*   **Time**: $O(M \times N)$
*   **Space**: $O(\min(M, N))$

---

## 📊 总结图解

| 场景 | 状态定义 | 递推方向 | 复杂度 |
| :--- | :--- | :--- | :--- |
| **最长递增子序列** | 一维 `dp[i]` | 回头看 `0...i-1` | $O(N^2)$ |
| **最长连续递增** | 一维 `dp[i]` | 只看 `i-1` | $O(N)$ |
| **最长公共子序列** | 二维 `dp[i][j]` | 左上、左、上 | $O(N \times M)$ |
```