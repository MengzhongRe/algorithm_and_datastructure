# Day 24: 动态规划 - 字符串子序列进阶 (String Subsequence Advanced)

**日期**: 2026-01-10
**主题**: 编辑距离前奏、二维 DP 计数、背包同构性分析
**标签**: #DynamicProgramming #String #Knapsack #SpaceOptimization

## 📖 今日概览
今天我们处理了三个关于 **“两个字符串关系”** 的经典问题。它们的核心状态定义都是 `dp[i][j]`（代表 s的前i个 和 t的前j个），但转移方程各有乾坤：
1.  **1035. 不相交的线**：求最长 $\rightarrow$ **LCS (最大值)**。
2.  **115. 不同的子序列**：求方案数 $\rightarrow$ **计数 DP (累加)**。
3.  **583. 两个字符串的删除操作**：求最小步数 $\rightarrow$ **最小化 (最小值)**。

---

## 💎 核心深究：115. 不同的子序列 (Distinct Subsequences)

**难度**: Hard
**链接**: [LeetCode 115](https://leetcode.cn/problems/distinct-subsequences/)

### 1. 题目解析
给定 `s` 和 `t`，求 `s` 的子序列中 `t` 出现的**个数**。
*   例子：`s = "bagg", t = "bag"`。
*   答案：2。因为 `s` 里的两个 'g' 都可以和前面的 'ba' 组成 "bag"。

### 2. 二维 DP 推导 (基础)

**状态定义**：
`dp[i][j]`：以 `s[i-1]` 结尾的源字符串子序列中，出现以 `t[j-1]` 结尾的目标字符串的**个数**。

**递推公式**：
当我们在计算 `dp[i][j]` 时，主要看 `s` 的当前字符 `s[i-1]` 和 `t` 的当前字符 `t[j-1]`：

1.  **当 `s[i-1] != t[j-1]` (不匹配)**：
    *   `s` 的这个字符毫无用处，像空气一样。
    *   结果完全继承自“没有这个字符”时的状态。
    *   $$ dp[i][j] = dp[i-1][j] $$

2.  **当 `s[i-1] == t[j-1]` (匹配)**：
    *   这是一个关键的分叉点，我们有两种选择，结果是两者的**和**：
    *   **选择 A (使用当前字符)**：用 `s[i-1]` 去匹配 `t[j-1]`。剩下的任务是看 `s` 的前面能匹配 `t` 的前面多少次。
        *   贡献值：`dp[i-1][j-1]`
    *   **选择 B (不使用当前字符)**：虽然匹配，但我任性，我把 `s[i-1]` 当作空气，试图用 `s` 前面的字符去匹配整个 `t[j]`。
        *   贡献值：`dp[i-1][j]`
    *   $$ dp[i][j] = dp[i-1][j-1] + dp[i-1][j] $$

**初始化**：
*   `dp[i][0] = 1`：`t` 是空串。无论 `s` 是什么，把 `s` 删光变成空串只有 **1** 种方法。这是递推的“火种”。

### 3. 一维滚动数组优化 (进阶)

我们发现 `dp[i][j]` 只依赖于 **上一行 (i-1)** 的当前位置 `j` 和左边位置 `j-1`。
因此，可以压缩为一维数组。

**递推公式的变化**：
$$ dp[j] \text{ (新)} = dp[j] \text{ (旧/上)} + dp[j-1] \text{ (旧/左上)} $$

**为什么必须倒序遍历？**
*   **依赖关系**：计算当前 `j` 时，我们需要用到 `j-1` 的**旧值**（即上一层 `i-1` 的值）。
*   **正序的问题**：如果从左往右 (1 -> n) 更新，当我们算到 `dp[j]` 时，`dp[j-1]` 已经在刚刚被更新成**新值**（当前层 `i` 的值）了。这导致数据污染。
*   **倒序的优势**：从右往左 (n -> 1) 更新，当我们算 `dp[j]` 时，左边的 `dp[j-1]` 还没动过，依然是上一层的**旧值**。**完美符合公式需求。**

**代码实现 (一维版)**：

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [0] * (n + 1)
        dp[0] = 1 # 初始化：凑出空串的方法为 1
        
        for i in range(1, m + 1):
            # 必须倒序！防止 dp[j-1] 被提前覆盖
            for j in range(n, 0, -1):
                if s[i-1] == t[j-1]:
                    dp[j] += dp[j-1]
                    
        return dp[n]
```

---

### 🧠 深度思考：与 0-1 背包的“同构性”

这道题在数学结构上，与 **0-1 背包求方案数** 是高度同构的。

**对比表：**

| 维度 | 0-1 背包 (LeetCode 494) | 不同的子序列 (LeetCode 115) |
| :--- | :--- | :--- |
| **外层循环** | 遍历 **物品** (Weight) | 遍历 **s 的字符** (Char) |
| **内层循环** | 遍历 **背包容量** | 遍历 **t 的位置** |
| **选择** | 放物品 vs 不放物品 | 匹配字符 vs 不匹配字符 |
| **状态依赖** | $dp[j]$ 依赖 $dp[j-w]$ (左侧旧值) | $dp[j]$ 依赖 $dp[j-1]$ (左侧旧值) |
| **运算逻辑** | 累加 (+) | 累加 (+) |
| **空间优化** | **必须倒序** | **必须倒序** |

**本质结论**：
*   在状态转移拓扑图中，两者的箭头流向完全一致（都是从左上和正上流向当前）。
*   因此，**倒序遍历** 这一空间优化技巧是通用的。

---

## 📝 其他题目复盘

### 题目一：1035. 不相交的线
**核心思路**：
*   连线不能相交 $\Leftrightarrow$ 相对顺序不变 $\Leftrightarrow$ **最长公共子序列 (LCS)**。
*   直接照搬 LCS 的代码即可。

```python
if nums1[i-1] == nums2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

### 题目三：583. 两个字符串的删除操作
**核心思路**：
*   **方法 A**：转化为 LCS。`步数 = len1 + len2 - 2 * LCS`。
*   **方法 B**：直接 DP (编辑距离简化版)。
    *   相等：`dp[i][j] = dp[i-1][j-1]` (不用删)
    *   不等：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1` (删s的一个，或者删t的一个，取最小)

---

## 📊 复杂度总结

| 题目 | 状态转移核心算子 | 复杂度 | 空间优化可行性 |
| :--- | :--- | :--- | :--- |
| **1035. 不相交线** | `max` (求长度) | $O(M \times N)$ | 可优化 (滚动数组) |
| **115. 不同的子序列** | `+` (求方案) | $O(M \times N)$ | **强烈推荐倒序一维 $O(N)$** |
| **583. 删除操作** | `min` (求步数) | $O(M \times N)$ | 可优化 |