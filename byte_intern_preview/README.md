### 1. 无重复字符的最长子串 (LeetCode 3)
**关键词：** `滑动窗口`、`哈希表`、`跳跃优化`

*   **核心逻辑：**
    *   维护一个窗口 `[left, right]`。
    *   `right` 主动向右扩张，寻找新领土。
    *   `left` 被动跳跃，当遇到重复字符时，**瞬移**到上一个重复字符的下一位。

*   **代码生死线 (3个细节)：**
    1.  **跳跃条件：** `if char in dic and dic[char] >= left:`。必须判断重复字符是否在**当前窗口内**（即 `>= left`），以前出现过的过期字符不要管。
    2.  **跳跃动作：** `left = dic[char] + 1`。不要跳到重复字符上，要跳到它后面。
    3.  **更新哈希：** 无论是否重复，都要更新 `dic[char] = right`，保持记录最新位置。

*   **复杂度：** 时间 $O(N)$，空间 $O(1)$ (字符集大小固定)。

---

### 2. 数组中的第 K 个最大元素 (LeetCode 215)
**关键词：** `快速选择 (Quick Select)`、`减治法`、`堆 (Heap)`

*   **核心逻辑 (面试首选 - 快速选择)：**
    *   利用快排的 Partition 思想。
    *   **目标转化：** 第 $K$ 大 = 排序后索引为 $N-K$ 的元素。
    *   **剪枝：** 每次切分后，看 Pivot 停在哪。如果停在目标左边，就只递归右边；停在右边，就只递归左边。**只排半边，效率翻倍。**

*   **工程逻辑 (备选 - 小顶堆)：**
    *   维护一个大小为 $K$ 的**小顶堆**（VIP 休息室）。
    *   遍历数组，比堆顶大的放进去，把堆顶踢出来。最后堆顶就是第 K 大。适合**海量数据流**。

*   **代码生死线：**
    1.  **随机基准：** 必须用 `random` 选 Pivot，否则遇到有序数组会退化成 $O(N^2)$。
    2.  **重复元素陷阱：** 遇到 `[1,1,1,1]` 这种数据，Partition 必须在遇到相等值时**停下交换**（左右指针交替），而不能一直滑过去，否则递归树会歪。

*   **复杂度：**
    *   Quick Select: 平均 $O(N)$。
    *   Heap: $O(N \log K)$。

---

### 3. 岛屿数量 (LeetCode 200)
**关键词：** `DFS (沉岛法)`、`BFS`、`连通分量`

*   **核心逻辑：**
    *   遍历地图，遇到 `1` (陆地) 就计数 `+1`。
    *   **核弹打击：** 立即触发 DFS/BFS，把当前这块陆地连通的所有 `1` 全部炸成 `0` (水)。
    *   继续遍历，确保不重复计数。

*   **面试博弈策略：**
    *   **首选 DFS (递归)：** 代码短，逻辑顺，写得快。
    *   **备选 BFS (队列)：** 如果面试官问“地图无限大”或“防止栈溢出”怎么办？答 BFS。

*   **代码生死线：**
    1.  **DFS 终止条件：** 越界 (`i<0` or `i>=m`) 或者 遇到水 (`grid[i][j] == '0'`)。
    2.  **BFS 标记时机：** **入队即标记！** 看到 `1`，立刻改成 `0` 再放入队列。千万不要等出队时再标记，否则内存会爆炸。

*   **复杂度：** 时间 $O(M \times N)$。虽然有递归，但每个格子一生只会被处理一次。

---

### 🧠 字节面试官的“隐形考点”总结

1.  **对于 LC 3：** 他看重你能不能用 `dict` 优化掉 `set` 的循环删除。
2.  **对于 LC 215：** 他看重你知不知道 `random pivot` 来避免最坏情况，以及面对全 1 数组时是否会死循环。
3.  **对于 LC 200：** 他看重你知不知道 DFS 有 **Stack Overflow (栈溢出)** 的风险。

**今晚好好休息，这些逻辑已经刻在你脑子里了。明天继续加油！**