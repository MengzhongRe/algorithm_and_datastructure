# Day 14: 贪心算法进阶 (Greedy Algorithms)

**日期**: 2025-12-26
**主题**: 区间问题、字符串贪心、数字逻辑贪心

---

## 题目一：56. 合并区间 (Merge Intervals)
**难度**: Medium
**标签**: #贪心 #排序 #区间

### 💡 核心解题思路
解决区间问题的万能钥匙是 **“排序”**。
只有当区间有序时，重叠的区间才会相邻，我们才有可能通过一次遍历完成合并。
本题的最佳策略是按照 **左边界 (Start Time)** 从小到大排序。

### 🔢 算法步骤
1.  **预处理**：将所有区间按照**左边界**进行升序排序。
2.  **初始化**：将排序后的第一个区间加入结果集 `result`。
3.  **遍历**：从第二个区间开始，依次与结果集中**最后一个区间**进行比较：
    *   **判定重叠**：如果当前区间的 **左边界** $\le$ 结果集中最后区间的 **右边界**。
    *   **执行合并**：结果集中最后区间的 **右边界** 更新为 `max(旧右边界, 当前右边界)`。
    *   **无重叠**：如果当前左边界大于旧右边界，说明断开了。直接将当前区间加入 `result`。

### 📊 复杂度分析
*   **时间复杂度**: $O(N \log N)$。虽然遍历只需 $O(N)$，但排序是瓶颈。
*   **空间复杂度**: $O(N)$ (用于存储排序后的数组或结果集)。

---

## 题目二：763. 划分字母区间 (Partition Labels)
**难度**: Medium
**标签**: #贪心 #哈希表 #双指针

### 💡 核心解题思路
这道题本质上是寻找 **“最远边界”**。
为了让同一个字母只出现在一个片段中，一个片段的结束位置，**至少**要包含这个片段内所有字符在字符串中最后出现的位置。

### 🔢 算法步骤
1.  **第一次遍历 (预处理)**：
    *   遍历字符串，记录每一个字符 **最后一次出现的下标**，存入哈希表 (Map)。
2.  **第二次遍历 (切分)**：
    *   维护两个指针：`left` (当前片段起点) 和 `right` (当前片段允许的最远终点)。
    *   遍历字符时，不断更新 `right`：`right = max(right, 当前字符的最后出现位置)`。
    *   **切分时刻**：当遍历索引 `i` 到达 `right` 时，说明在 `[left, right]` 这个范围内出现的所有字符，它们的最远边界都在 `right` 左边，不可能跑出去了。
    *   **记录结果**：片段长度为 `right - left + 1`，然后更新 `left` 为 `i + 1`。

### 📊 复杂度分析
*   **时间复杂度**: $O(N)$。字符串被扫描了两次。
*   **空间复杂度**: $O(1)$。哈希表最多存储 26 个小写字母的索引。

---

## 题目三：738. 单调递增的数字 (Monotone Increasing Digits)
**难度**: Medium
**标签**: #贪心 #数学 #逻辑

### 💡 核心解题思路
这道题不能从前向后遍历，因为高位的修改会影响低位的单调性（牵一发而动全身）。
**最优策略是：从后向前遍历。**
一旦发现逆序（前一位 > 后一位），就执行 **“借位减一，后面全变大”** 的贪心操作。

### 📝 数学/逻辑证明
我们需要找一个数 $M \le N$，使得 $M$ 单调递增且最大。

**证明策略的正确性：**
1.  **为什么遇到逆序要“前位减 1”？**
    假设在位置 $i$ 和 $i+1$ 出现逆序 ($D_i > D_{i+1}$)。为了保持单调性，位置 $i+1$ 的数字必须 $\ge D_i$。但如果 $M$ 的前 $i$ 位与 $N$ 相同，那么 $M$ 在位置 $i+1$ 的值必然大于 $N$ 的对应位，导致 $M > N$。
    因此，为了保证 $M \le N$，必须破坏前 $i$ 位的相等关系，即让 $D_i$ 减小。为了让 $M$ 尽可能大，减幅越小越好，所以 $D_i \leftarrow D_i - 1$。
2.  **为什么“后面全变 9”？**
    既然高位 $D_i$ 已经减小了，那么无论低位（$i$ 后面的位）是什么，$M$ 整体一定小于 $N$。为了满足 **最大性**，低位应当取能取的最大值，即 9。
3.  **为什么要“从后向前”？**
    考虑数字 `332`。如果从前向后：
    *   `3` vs `3` (OK) -> `3` vs `2` (不OK，变 `329`)。
    *   结果 `329` 依然不单调 (`3 > 2`)。
    从后向前则能处理这种**级联**情况：
    *   `3` vs `2` (后两位) -> 变 `29`。当前为 `329`。
    *   `3` vs `2` (前两位) -> 变 `29`。当前为 `299`。
    *   结果 `299` 正确。

### 🔢 算法步骤
1.  将数字转换为字符列表/数组（方便修改）。
2.  **从后向前**遍历数组（从倒数第二位开始）：
    *   如果 `nums[i] > nums[i+1]`（当前位大于后一位）：
        *   当前位 `nums[i]` 减 1。
        *   记录一个标记 `flag = i + 1`，表示从这一位开始后面都要变成 9。
3.  **统一赋值**：将 `flag` 之后的所有位全部设为 9。
4.  将列表转回整数返回。

### 📊 复杂度分析
*   **时间复杂度**: $O(\log N)$ (即数字的位数，对于 10 亿以内的数，循环次数极少)。
*   **空间复杂度**: $O(\log N)$ (需要将数字转为字符串/列表处理)。





